import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import xgboost as xgb
import shap
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
from scipy import stats

try:
    plt.rcParams['font.family'] = ['DejaVu Sans', 'Arial']
    plt.rcParams['axes.unicode_minus'] = False
except:
    plt.rcParams['font.family'] = ['DejaVu Sans', 'Arial']
    plt.rcParams['axes.unicode_minus'] = False


def add_noise(X, noise_factor=0.05):
    noise = np.random.normal(loc=0.0, scale=noise_factor, size=X.shape)
    X_noisy = X + noise
    return X_noisy


def remove_data_by_indices(data, indices_to_remove):
    mask = np.ones(len(data), dtype=bool)
    mask[indices_to_remove] = True

    if isinstance(data, pd.DataFrame):
        filtered_data = data[mask]
    elif isinstance(data, np.ndarray):
        filtered_data = data[mask]
    elif isinstance(data, list):
        filtered_data = [data[i] for i in range(len(data)) if i not in indices_to_remove]
    else:
        raise ValueError

    return filtered_data


if __name__ == '__main__':
    random_state = 42
    np.random.seed(random_state)

    file_path = r"C:\Users\Administrator\Desktop\机器学习11.10\Supporting Input Dataset.csv"

    encodings = ['utf-8', 'gbk', 'gb2312', 'latin1', 'cp1252']
    data = None

    for encoding in encodings:
        try:
            data = pd.read_csv(file_path, encoding=encoding)
            print(f"Successfully read file with {encoding} encoding")
            break
        except UnicodeDecodeError:
            print(f"{encoding} encoding failed, trying next...")
            continue
        except Exception as e:
            print(f"{encoding} encoding error: {e}")
            continue

    if data is None:
        raise ValueError("Unable to read file, please check file path and encoding")

    print("First few rows of data:")
    print(data.head())
    print("Data shape:", data.shape)

    if data.shape[1] != 16:
        raise ValueError("Number of columns does not meet expectations, should have 16 columns!")

    X = data.iloc[:, :-1].values
    y = data.iloc[:, -1].values

    X[:, 0] = X[:, 0] * 100.0

    z_scores = np.abs(stats.zscore(X))
    threshold = 3
    mask = (z_scores < threshold).all(axis=1)
    X_cleaned = X[mask]
    y_cleaned = y[mask]

    len_test = int(len(X_cleaned) * 0.2)
    test_indices = np.random.choice(len(X_cleaned), size=len_test, replace=False)

    X_augmented_list = [X_cleaned]
    y_augmented_list = [y_cleaned]
    expansion_factor = 1
    for _ in range(expansion_factor - 1):
        X_noisy = add_noise(X_cleaned, noise_factor=0.05)
        X_augmented_list.append(X_noisy)
        y_augmented_list.append(y_cleaned)

    X_augmented = np.vstack(X_augmented_list)
    y_augmented = np.hstack(y_augmented_list)

    median_values = np.nanmedian(X_augmented, axis=0)
    nan_mask = np.isnan(X_augmented)
    X_augmented[nan_mask] = np.take(median_values, np.where(nan_mask)[1])

    min_values = np.min(X_augmented, axis=0)
    max_values = np.max(X_augmented, axis=0)
    range_values = max_values - min_values
    zero_range = range_values == 0
    if zero_range.any():
        range_values[zero_range] = 1.0
    X_normalized = (X_augmented - min_values) / range_values

    X_test, y_test = X_normalized[test_indices], y_augmented[test_indices]
    X_train = remove_data_by_indices(X_normalized, test_indices)
    y_train = remove_data_by_indices(y_augmented, test_indices)

    model = xgb.XGBRegressor(
        objective='reg:squarederror',
        random_state=random_state,
        max_depth=3,
        min_child_weight=1,
        gamma=0.1,
        reg_lambda=0.3,
        reg_alpha=0.4
    )
    best_model = model.fit(X_train, y_train)
    y_pred_train = best_model.predict(X_train)
    y_pred_test = best_model.predict(X_test)

    train_r2 = r2_score(y_train, y_pred_train)
    test_r2 = r2_score(y_test, y_pred_test)
    mse_test = mean_squared_error(y_test, y_pred_test)
    mae_test = mean_absolute_error(y_test, y_pred_test)

    print("\nTraining set evaluation results:")
    print(f"R² (training set): {train_r2:.4f}")
    print("\nTest set evaluation results:")
    print(f"R² (test set): {test_r2:.4f}")
    print(f"MSE (test set): {mse_test:.4f}")
    print(f"MAE (test set): {mae_test:.4f}")

    plt.rcParams['font.family'] = 'Arial'

    plt.figure(figsize=(12, 10))
    g = sns.JointGrid(height=8, ratio=5, space=0)

    scatter_train = g.ax_joint.scatter(y_train, y_pred_train, color='blue', edgecolor='white',
                                       alpha=0.7, s=60, linewidth=0.5)
    scatter_test = g.ax_joint.scatter(y_test, y_pred_test, color='green', edgecolor='white',
                                      alpha=0.7, s=60, linewidth=0.5)

    min_val = min(min(y_train), min(y_test))
    max_val = max(max(y_train), max(y_test))
    g.ax_joint.plot([min_val, max_val], [min_val, max_val],
                    color='red', linestyle='--', linewidth=1.5, label="Ideal line")

    text_str = f'Train R² = {train_r2:.3f}\nTest R² = {test_r2:.3f}'
    g.ax_joint.text(0.05, 0.95, text_str, transform=g.ax_joint.transAxes,
                    fontsize=26, fontname='Arial',
                    verticalalignment='top')

    g.ax_joint.set_xlabel('True Values', fontsize=20, fontname='Arial')
    g.ax_joint.set_ylabel('Predicted Values', fontsize=20, fontname='Arial')

    g.ax_joint.tick_params(axis='both', which='major', labelsize=18)

    hist_true = sns.histplot(x=y_train, ax=g.ax_marg_x, color='blue', alpha=0.5,
                             kde=True, linewidth=0)
    sns.histplot(x=y_test, ax=g.ax_marg_x, color='green', alpha=0.5,
                 kde=True, linewidth=0)

    hist_pred = sns.histplot(y=y_pred_train, ax=g.ax_marg_y, color='blue', alpha=0.5,
                             kde=True, linewidth=0)
    sns.histplot(y=y_pred_test, ax=g.ax_marg_y, color='green', alpha=0.5,
                 kde=True, linewidth=0)

    for ax in [g.ax_joint, g.ax_marg_x, g.ax_marg_y]:
        for spine in ax.spines.values():
            spine.set_color('black')
            spine.set_linewidth(1.5)
        ax.grid(False)
        ax.tick_params(labelsize=22)

    g.ax_marg_x.set_facecolor('white')
    g.ax_marg_y.set_facecolor('white')

    g.ax_marg_x.set_position([g.ax_joint.get_position().x0,
                              g.ax_joint.get_position().y1 + 0.01,
                              g.ax_joint.get_position().width,
                              0.15])
    g.ax_marg_y.set_position([g.ax_joint.get_position().x1 + 0.01,
                              g.ax_joint.get_position().y0,
                              0.15,
                              g.ax_joint.get_position().height])

    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', label=f'Train set',
                   markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='o', color='w', label=f'Test set',
                   markerfacecolor='green', markersize=10),
        plt.Line2D([0], [0], color='red', linestyle='--', label='Ideal line')
    ]
    legend = g.ax_joint.legend(handles=legend_elements, loc='lower right',
                               framealpha=0.9, prop={'family': 'Arial', 'size': 16})

    plt.tight_layout()
    plt.show()

    plt.tight_layout()
    plt.show()
